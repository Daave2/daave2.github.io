  <script>
  (()=>{ // Start new IIFE
    'use strict';

    /* -------- Define Helper Functions FIRST -------- */
    const $ = s=>document.querySelector(s);
    const $$= s=>document.querySelectorAll(s);
    const debounce = (fn,ms)=>{let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),ms);} };
    const notify=(msg,ms=3000)=>{const n=$("#notification");if(!n)return;n.textContent=msg;n.style.display="block";n.style.opacity=1;n.style.transition='opacity .3s';
                                 setTimeout(()=>{n.style.opacity=0;setTimeout(()=>n.style.display="none",300);},ms);};

    /* -------- dark-mode toggle -------- */
    const themeBtn=$(".theme-toggle");
    // Need resizeCanvas defined before setMode calls it
    let resizeCanvas = () => {}; // Placeholder, will be properly defined later if canvas exists
    const setMode=isDark=>{document.body.classList.toggle("dark-mode",isDark);themeBtn.setAttribute("aria-pressed",isDark);localStorage.theme=isDark?"dark":"light";if(typeof resizeCanvas==='function')setTimeout(resizeCanvas,50)};
    themeBtn.addEventListener("click",()=>setMode(!document.body.classList.contains("dark-mode")));
    const saved=localStorage.theme;setMode(saved?saved==="dark":matchMedia("(prefers-color-scheme:dark)").matches);
    matchMedia("(prefers-color-scheme:dark)").addEventListener("change",e=>{if(!localStorage.theme)setMode(e.matches);});

    /* -------- Dashboard Tile Click Handler & Iframe -------- */
    const dashboardTiles = $$('#dashboard .tile');
    const frameContainer = $('#frame-container');
    const contentFrame = $('#content-frame');
    const closeFrame = $('#close-frame');
    const fallbackMessage = $('#fallback-message');
    const fallbackLink = $('#fallback-link');
    const frameSpinner = frameContainer?.querySelector('.iframe-loading');
    let frameLoadTimeout;
    function showFrameSpinner(show) { if (frameSpinner) frameSpinner.style.display = show ? 'block' : 'none'; }

    function loadContentInFrame(url) {
         if (!frameContainer || !contentFrame || !fallbackLink || !fallbackMessage || !closeFrame ) return;
         contentFrame.src = 'about:blank';
         fallbackMessage.style.display = 'none';
         fallbackLink.href = url;
         frameContainer.classList.add('active');
         showFrameSpinner(true);
         contentFrame.src = url;
         frameContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
         clearTimeout(frameLoadTimeout);
         frameLoadTimeout = setTimeout(() => {
           let wasBlockedOrFailed = false;
           try {
             const doc = contentFrame.contentDocument || contentFrame.contentWindow?.document;
             if (contentFrame.src !== 'about:blank' && (!doc || !doc.body || doc.body.innerHTML.trim() === "")) {
                 console.warn('[Fallback Check] iframe content seems empty or inaccessible after timeout for:', url);
                 wasBlockedOrFailed = true;
             }
           } catch (e) {
             console.warn('[Fallback Check] Cross-origin error accessing iframe content after timeout for:', url, e);
             wasBlockedOrFailed = true;
           }
           if (wasBlockedOrFailed && frameSpinner && frameSpinner.style.display !== 'none') {
             console.log('[Fallback Action] Opening in new tab due to suspected blocking/failure for:', url);
             window.open(url,'_blank','noopener');
             frameContainer.classList.remove('active');
             showFrameSpinner(false);
             notify('Opened in new tab (embedding blocked/failed).', 4000);
           } else if (frameSpinner && frameSpinner.style.display !== 'none') {
               showFrameSpinner(false);
               fallbackMessage.style.display = 'block';
               notify("Content took too long to load.", 4000);
           }
         }, 5000);
         contentFrame.onload = function() {
             clearTimeout(frameLoadTimeout);
             showFrameSpinner(false);
             fallbackMessage.style.display = 'none';
             console.log('[iframe onload] Fired for:', contentFrame.src);
         };
         contentFrame.onerror = function(err) {
             clearTimeout(frameLoadTimeout);
             showFrameSpinner(false);
             fallbackMessage.style.display = 'block';
             console.error('[iframe onerror] Fired for:', contentFrame.src, err);
             notify("Error loading content in frame.", 4000);
         };
       } // --- End of loadContentInFrame ---

    if (closeFrame) { closeFrame.addEventListener('click', function() { if (!frameContainer || !contentFrame) return; frameContainer.classList.remove('active'); contentFrame.src = "about:blank"; fallbackMessage.style.display = "none"; showFrameSpinner(false); clearTimeout(frameLoadTimeout); }); }

    dashboardTiles.forEach(item => {
        item.addEventListener('click', function(e) {
            const url = this.getAttribute('href');
            const openType = this.dataset.open;
            if (openType === "external") {
                e.preventDefault();
                window.open(url, '_blank', 'noopener,noreferrer');
            } else if (openType === "frame") {
                e.preventDefault();
                loadContentInFrame(url);
            }
        });
    });

    /* -------- WHITEBOARD -------- */
    const container=$("#whiteboard-container");
    const canvas   =$("#whiteboard");
    if(canvas){ // Check if canvas exists before proceeding
        const ctx=canvas.getContext("2d");
        const tools=$$(".tool-button");
        const colorPicker=$("#colorPicker");
        const brushSel=$("#brushSize");
        const fontSel=$("#fontSize");
        const eraserPreview=$("#eraser-preview");
        const fsBtn=$(".fullscreen-button");

        let currentTool="pen",drawing=false,currentStroke=null,strokes=[];
        let dpr=window.devicePixelRatio||1;

        /*  util  */
        const themeBg = ()=>getComputedStyle(document.body).getPropertyValue(document.body.classList.contains("dark-mode")?"--dark-bg-color":"--light-bg-color").trim();
        const effectiveBg = ()=>{const f=[...strokes].reverse().find(s=>s.tool==="fill");return f?f.color:themeBg();};
        const getPos=e=>{const r=canvas.getBoundingClientRect();const clientX=e.touches?e.touches[0].clientX:e.clientX;const clientY=e.touches?e.touches[0].clientY:e.clientY;if(clientX==null||clientY==null)return null;const x=clientX-r.left;const y=clientY-r.top;return{x,y};};

        /*  size / Hi-DPI  */
        // Redefine resizeCanvas properly within this scope
        resizeCanvas=()=>{
          if (!canvas.parentElement) return;
          const {clientWidth:w,clientHeight:h}=canvas.parentElement;
          dpr=window.devicePixelRatio||1;
          canvas.width=w*dpr;canvas.height=h*dpr;
          canvas.style.width=w+"px";canvas.style.height=h+"px";
          ctx.setTransform(dpr,0,0,dpr,0,0);
          render();
        };

        /* drawing engine */
        const render=()=>{
          if(!ctx) return;
          const logicalWidth = canvas.width / dpr;
          const logicalHeight = canvas.height / dpr;
          ctx.save();
          // Clear based on physical pixels, but apply transform for drawing logical pixels
          ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform to clear properly
          ctx.clearRect(0,0,canvas.width,canvas.height);

          ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // Apply transform for drawing
          ctx.fillStyle=effectiveBg();
          ctx.fillRect(0,0,logicalWidth,logicalHeight);

          for(const s of strokes){
            if(!s)continue;
            ctx.globalCompositeOperation="source-over";
            if(s.tool==="pen"||s.tool==="eraser"){
              if (!s.p || !s.p.length) continue;
              ctx.lineJoin=ctx.lineCap="round";
              ctx.lineWidth=s.w;
              ctx.strokeStyle=s.tool==="eraser"?"rgba(0,0,0,1)":s.c;
              ctx.globalCompositeOperation=s.tool==="eraser"?"destination-out":"source-over";
              ctx.beginPath();ctx.moveTo(s.p[0].x,s.p[0].y);
              s.p.forEach(pt=>ctx.lineTo(pt.x,pt.y));
              ctx.stroke();
            }
            else if(s.tool==="text"){
              ctx.fillStyle=s.c;
              ctx.font=`${s.sz}px Roboto, sans-serif`;
              ctx.textAlign = 'left';
              ctx.textBaseline = 'top';
              s.lines.forEach((ln,i)=>ctx.fillText(ln,s.x,s.y+i*s.sz*1.2));
            }
            else if(s.tool==="fill"){
              ctx.fillStyle=s.color;
              ctx.fillRect(0,0,logicalWidth,logicalHeight);
            }
          }
          ctx.restore();
        };

        const saveLocal=debounce(()=>{try{localStorage.whiteboardStrokes=JSON.stringify(strokes)}catch(e){notify("Save failed: Storage full?",5000)}},400);

        /* pointer handlers */
        const start=e=>{
          if(e.type==='touchstart') e.preventDefault();
          const pos=getPos(e); if (!pos) return;
          commitText();
          if(currentTool==="text"){makeTextInput(pos);return;}
          drawing=true;
          currentStroke={tool:currentTool,c:colorPicker.value,w:+brushSel.value,p:[pos]};
        };

        const move=e=>{
          if(e.type==='touchmove') e.preventDefault();
          const pos = getPos(e); if (!pos) return;
          if(currentTool==="eraser")updateEraserPreview(e);
          if(!drawing||currentTool==="text"||!currentStroke)return;
          const prev=currentStroke.p.at(-1);
          if (!prev) return;

          ctx.save();
          ctx.setTransform(dpr,0,0,dpr,0,0); // Apply scaling for drawing segment
          ctx.lineWidth=currentStroke.w;
          ctx.strokeStyle=currentStroke.tool==="eraser"?"rgba(0,0,0,1)":currentStroke.c;
          ctx.globalCompositeOperation=currentStroke.tool==="eraser"?"destination-out":"source-over";
          ctx.lineJoin = ctx.lineCap = 'round';
          ctx.beginPath();ctx.moveTo(prev.x,prev.y);ctx.lineTo(pos.x,pos.y);ctx.stroke();
          ctx.restore();

          currentStroke.p.push(pos);
        };

        const end=()=>{hideEraserPreview();if(!drawing)return;drawing=false;
          if(currentStroke&¤tStroke.p.length>1)strokes.push(currentStroke);
          currentStroke=null;
          saveLocal();
        };

        /* text tool */
        let input=null;
        const makeTextInput=pos=>{
          if(input)return;
          input=document.createElement("textarea");
          input.id="text-input-overlay";
          const off=canvas.getBoundingClientRect();
          input.style.left=(off.left+window.scrollX+pos.x)+"px";
          input.style.top =(off.top+window.scrollY +pos.y)+"px";
          input.style.fontSize=fontSel.value+"px";
          input.style.color=colorPicker.value;
          input.style.fontFamily='Roboto, sans-serif';
          input.style.lineHeight = '1.2';
          input.style.padding = '4px';
          input.style.border = '1px dashed grey';
          input.style.resize = 'none';
          input.onblur=commitText;
          input.onkeydown=e=>{if(e.key==="Enter"&&!e.shiftKey){e.preventDefault();commitText();}};
          document.body.appendChild(input);input.focus();
        };
        const commitText=()=>{
          if(!input)return;
          const txt=input.value;
          const off=canvas.getBoundingClientRect();
          const x=parseFloat(input.style.left)-off.left-window.scrollX;
          const y=parseFloat(input.style.top )-off.top -window.scrollY;
          const sz = +fontSel.value;
          const col = colorPicker.value;
          document.body.removeChild(input);input=null;
          if(!txt.trim())return;
          strokes.push({tool:"text",lines:txt.split("\n"),x,y,sz,c:col});
          render();saveLocal();
        };

        /* eraser preview */
        const updateEraserPreview=e=>{
          const p=getPos(e); if (!p) return; const size=+brushSel.value; // Use logical size for CSS pixels
          eraserPreview.style.cssText=`display:block;width:${size}px;height:${size}px;left:${canvas.offsetLeft+p.x-size/2}px;top:${canvas.offsetTop+p.y-size/2}px`; // Position based on logical coords
        };
        const hideEraserPreview=()=>eraserPreview.style.display="none";

        /* full-screen */
        fsBtn.onclick=()=>{
          if(!document.fullscreenElement){
             container.requestFullscreen().catch(()=>notify("Full-screen failed"));
          }else{
             document.exitFullscreen();
          }
        };
        document.addEventListener("fullscreenchange",()=>{
          const full=!!document.fullscreenElement;
          fsBtn.classList.toggle("full",full);
          fsBtn.innerHTML=`<i class="fas fa-${full?'compress':'expand'}"></i>`;
          fsBtn.setAttribute("aria-label",full?"Exit full screen (Esc)":"Full screen (⌘/Ctrl-F)");
          setTimeout(resizeCanvas, 100);
        });

        /* hot-keys */
        addEventListener("keydown",e=>{
          if(e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return; // Ignore inputs
          if((e.metaKey||e.ctrlKey)&&e.key==="s"){e.preventDefault();$(".save-button")?.click();} // Use optional chaining
          if((e.metaKey||e.ctrlKey)&&e.key==="z"){e.preventDefault();$(".undo-button")?.click();}
          if((e.metaKey||e.ctrlKey)&&e.key.toLowerCase()==="f"){e.preventDefault();fsBtn?.click();}
        });

        /* UI wiring */
        canvas.addEventListener("mousedown",start);
        canvas.addEventListener("mousemove",move);
        canvas.addEventListener("mouseup",end);
        canvas.addEventListener("mouseleave",end);
        canvas.addEventListener("touchstart",start,{passive:false});
        canvas.addEventListener("touchmove",move,{passive:false});
        canvas.addEventListener("touchend",end);
        canvas.addEventListener("touchcancel",end);

        tools.forEach(b=>b.onclick=()=>{commitText();tools.forEach(x=>x.classList.toggle("active",x===b));currentTool=b.dataset.tool;hideEraserPreview();});

        $(".undo-button")?.addEventListener('click', ()=>{if(strokes.pop()){render();saveLocal();notify("Undo");}}); // Use addEventListener
        $(".clear-button")?.addEventListener('click', ()=>{strokes=[];localStorage.removeItem("whiteboardStrokes");render();notify("Cleared");});
        $(".fill-button")?.addEventListener('click', ()=>{strokes.push({tool:"fill",color:colorPicker.value});render();saveLocal();notify("Background filled");});
        $(".save-button")?.addEventListener('click', ()=>{saveLocal.flush?.();localStorage.setItem('whiteboardStrokes', JSON.stringify(strokes)); notify("Saved");});
        $(".load-button")?.addEventListener('click', ()=>{
          let raw=localStorage.whiteboardStrokes;try{strokes=raw?JSON.parse(raw):[];}catch{strokes=[];}
          render();notify(strokes.length?"Loaded":"Nothing saved");
        });
        $(".export-png-button")?.addEventListener('click',()=>{
          const a=document.createElement("a");a.href=canvas.toDataURL("image/png");a.download="morrisons-notes.png";a.click();notify("PNG downloaded");
        });

        /* initial load */
        window.addEventListener("resize",debounce(resizeCanvas,200));
        try{strokes=JSON.parse(localStorage.whiteboardStrokes||"[]");}catch{strokes=[];}
        setTimeout(resizeCanvas, 50); // Initial render after layout settles

    } else { console.log("Whiteboard canvas not found."); } // End if(canvas)


    /* --- Lazy Load Iframes & Add Spinners --- */
     function initLazyIframes() {
         const iframes = $$('iframe[data-src]'); // Use $$ helper

         const observerCallback = (entries, obs) => {
             entries.forEach(entry => {
                 if (entry.isIntersecting) {
                     const iframe = entry.target;
                     const loadingContainer = iframe.closest('section')?.querySelector('.iframe-loading-container');
                     const loader = loadingContainer?.querySelector('.iframe-loading');

                     if (loader) {
                          loader.style.display = 'block';
                      }
                     iframe.src = iframe.getAttribute('data-src');
                     iframe.removeAttribute('data-src');

                     iframe.addEventListener('load', () => { if(loader) loader.style.display = 'none';});
                     iframe.addEventListener('error', (err) => {
                         if(loader) loader.style.display = 'none';
                         console.error("Error loading iframe:", iframe.title || iframe.src, err);
                         const errorMsg = document.createElement('p');
                         errorMsg.textContent = 'Error loading content.';
                         errorMsg.style.textAlign = 'center';
                         errorMsg.style.padding = '20px';
                         errorMsg.style.color = 'red';
                         const iframeWrapper = iframe.closest('.iframe-wrap');
                         if(iframeWrapper && !iframeWrapper.querySelector('.error-message')) {
                             errorMsg.classList.add('error-message');
                             iframeWrapper.appendChild(errorMsg);
                         }
                     });

                     obs.unobserve(iframe);
                 }
             });
         };

          const observerOptions = {
            rootMargin: '100px 0px',
            threshold: 0.01
        };

        const observer = new IntersectionObserver(observerCallback, observerOptions);

        iframes.forEach(iframe => {
            const loadingContainer = iframe.closest('section')?.querySelector('.iframe-loading-container');
            const loader = loadingContainer?.querySelector('.iframe-loading');

            if(loader) {
                loader.style.display = 'none';
            }

            if ('IntersectionObserver' in window) {
                observer.observe(iframe);
            } else {
                if (loader) loader.style.display = 'block';
                iframe.src = iframe.getAttribute('data-src');
                iframe.removeAttribute('data-src');
                iframe.addEventListener('load', () => { if(loader) loader.style.display = 'none'; });
                iframe.addEventListener('error', () => { if(loader) loader.style.display = 'none'; });
            }
        });
    }


    /* --- DOMContentLoaded --- */
    document.addEventListener('DOMContentLoaded', () => { initLazyIframes(); });

    /* --- PWA Service Worker Registration --- */
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then(registration => {
            console.log('Service Worker registered successfully with scope: ', registration.scope);
          })
          .catch(err => {
            console.error('Service Worker registration failed: ', err);
          });
      });
    }

  })(); // End of IIFE
  </script>
</body>
</html>
