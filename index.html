  <script>
    (function() {
      'use strict';
      /* --- Helper: Debounce --- */
      function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func.apply(this, args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }

      /* --- Dark Mode Toggle --- */
      const darkModeToggleButtons = document.querySelectorAll('.dark-mode-toggle');
      function setDarkMode(isDark) { document.body.classList.toggle('dark-mode', isDark); darkModeToggleButtons.forEach(btn => btn.setAttribute('aria-pressed', isDark)); localStorage.setItem('theme', isDark ? 'dark' : 'light'); if (typeof resizeCanvas === 'function') { setTimeout(resizeCanvas, 50); } }
      darkModeToggleButtons.forEach(btn => { btn.addEventListener('click', () => setDarkMode(!document.body.classList.contains('dark-mode'))); });
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme) { setDarkMode(savedTheme === 'dark'); } else { const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; setDarkMode(prefersDark); }
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => { if (!localStorage.getItem('theme')) { setDarkMode(event.matches); } });

      /* --- Mobile Navigation Toggle --- */
       const hamburger = document.querySelector('.hamburger');
       const navLinks = document.querySelector('.nav-links');
       if (hamburger && navLinks) { const toggleNav = () => { const isActive = navLinks.classList.toggle('active'); hamburger.classList.toggle('active'); hamburger.setAttribute('aria-expanded', isActive); document.body.classList.toggle('mobile-nav-open', isActive); }; hamburger.addEventListener('click', (e) => { e.stopPropagation(); toggleNav(); }); hamburger.addEventListener('keypress', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); hamburger.click(); } }); document.addEventListener('click', (e) => { if (navLinks.classList.contains('active') && !navLinks.contains(e.target) && !hamburger.contains(e.target)) { toggleNav(); } }); navLinks.querySelectorAll('a').forEach(link => { link.addEventListener('click', () => { if (navLinks.classList.contains('active')) { toggleNav(); } }); }); }

      /* --- Notification System --- */
      function showNotification(message, duration = 3000) { const notification = document.getElementById('notification'); if (!notification) return; notification.textContent = message; notification.style.display = 'block'; notification.style.opacity = 1; setTimeout(() => { notification.style.opacity = 0; setTimeout(() => { notification.style.display = 'none'; }, 300); }, duration); }

       /* --- Dashboard Item Click Handler & Iframe --- */
       const dashboardItems = document.querySelectorAll('#dashboard .dashboard-item');
       const frameContainer = document.getElementById('frame-container');
       const contentFrame = document.getElementById('content-frame');
       const closeFrame = document.getElementById('close-frame');
       const fallbackMessage = document.getElementById('fallback-message');
       const fallbackLink = document.getElementById('fallback-link');
       const frameSpinner = frameContainer ? frameContainer.querySelector('.iframe-loading') : null;
       let frameLoadTimeout;
       function showFrameSpinner(show) { if (frameSpinner) frameSpinner.style.display = show ? 'block' : 'none'; }
       function loadContentInFrame(url) { if (!frameContainer || !contentFrame || !fallbackLink || !fallbackMessage || !closeFrame ) return; contentFrame.src = "about:blank"; fallbackMessage.style.display = "none"; fallbackLink.href = url; frameContainer.classList.add('active'); showFrameSpinner(true); contentFrame.src = url; clearTimeout(frameLoadTimeout); frameLoadTimeout = setTimeout(() => { showFrameSpinner(false); fallbackMessage.style.display = "block"; showNotification("Content took too long to load.", 4000); }, 15000); frameContainer.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
       if (contentFrame) { contentFrame.onload = function() { clearTimeout(frameLoadTimeout); showFrameSpinner(false); let accessible = false; try { const doc = contentFrame.contentDocument || contentFrame.contentWindow?.document; if (doc && doc.body && doc.body.childNodes.length > 0) { accessible = true; } else if (doc) { accessible = true; } } catch (e) { accessible = true; console.warn("Cross-origin frame loaded.", e); } fallbackMessage.style.display = accessible ? "none" : "block"; }; contentFrame.onerror = function() { clearTimeout(frameLoadTimeout); showFrameSpinner(false); fallbackMessage.style.display = "block"; showNotification("Error loading content in frame.", 4000); }; }
       dashboardItems.forEach(item => { item.addEventListener('click', function(e) { const url = this.getAttribute('href'); const openType = this.dataset.open; if (openType === "external") { e.preventDefault(); window.open(url, '_blank', 'noopener,noreferrer'); } else if (openType === "frame") { e.preventDefault(); loadContentInFrame(url); } }); });
       if (closeFrame) { closeFrame.addEventListener('click', function() { if (!frameContainer || !contentFrame) return; frameContainer.classList.remove('active'); contentFrame.src = "about:blank"; fallbackMessage.style.display = "none"; showFrameSpinner(false); clearTimeout(frameLoadTimeout); }); }

      /* --- Whiteboard Setup --- */
      const canvas = document.getElementById('whiteboard');
      let ctx, colorPicker, brushSizeSelect, fontSizeSelect, currentTool = 'pen', strokes = [], currentStroke = null, drawing = false, textInputOverlay = null;
      const eraserPreview = document.getElementById('eraser-preview');

      if (canvas) {
           ctx = canvas.getContext('2d'); // Removed willReadFrequently for simplicity now
           colorPicker = document.getElementById('colorPicker');
           brushSizeSelect = document.getElementById('brushSize');
           fontSizeSelect = document.getElementById('fontSize');
           const toolButtons = document.querySelectorAll('.tool-button'); // Get tool buttons

           const getThemeBgColor = () => { const styles = getComputedStyle(document.documentElement); return document.body.classList.contains('dark-mode') ? styles.getPropertyValue('--dark-bg-color').trim() : styles.getPropertyValue('--light-bg-color').trim(); }
           const getEffectiveBackgroundColor = () => { const lastFill = strokes.slice().reverse().find(stroke => stroke.tool === 'fill'); return lastFill ? lastFill.color : getThemeBgColor(); };

            const renderAll = () => {
                // Function to render all strokes onto the canvas
                if (!ctx) return;
                const ratio = window.devicePixelRatio || 1;
                const width = canvas.width / ratio;
                const height = canvas.height / ratio;
                const originalCompositeOperation = ctx.globalCompositeOperation; // Save state

                // Clear canvas with the *effective* background color (handles fill)
                ctx.fillStyle = getEffectiveBackgroundColor();
                ctx.fillRect(0, 0, width, height);
                ctx.globalCompositeOperation = 'source-over'; // Reset for drawing strokes

                // Draw each stroke
                strokes.forEach(stroke => {
                    if (!stroke) return;
                    // Pen Strokes
                    if (stroke.tool === 'pen' && stroke.points && stroke.points.length > 0) {
                        ctx.globalCompositeOperation = 'source-over'; // Ensure normal drawing
                        ctx.lineJoin = 'round';
                        ctx.lineCap = 'round';
                        ctx.lineWidth = stroke.lineWidth;
                        ctx.strokeStyle = stroke.color;
                        ctx.beginPath();
                        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                        for (let i = 1; i < stroke.points.length; i++) {
                            if (stroke.points[i]) ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                        }
                        ctx.stroke();
                    }
                    // Eraser Strokes (Crucial Fix Here)
                    else if (stroke.tool === 'eraser' && stroke.points && stroke.points.length > 0) {
                        ctx.globalCompositeOperation = 'destination-out'; // Set eraser mode *for this stroke*
                        ctx.lineJoin = 'round';
                        ctx.lineCap = 'round';
                        ctx.lineWidth = stroke.lineWidth; // Eraser uses stored line width
                        // Color doesn't matter for destination-out, but use black for consistency
                        ctx.strokeStyle = '#000000';
                        ctx.beginPath();
                        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                        for (let i = 1; i < stroke.points.length; i++) {
                            if (stroke.points[i]) ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                        }
                        ctx.stroke();
                        ctx.globalCompositeOperation = 'source-over'; // **Reset** to normal after erasing stroke
                    }
                    // Text Strokes
                    else if (stroke.tool === 'text') {
                        ctx.globalCompositeOperation = 'source-over'; // Ensure normal drawing
                        ctx.fillStyle = stroke.color;
                        ctx.font = `${stroke.fontSize}px Roboto, sans-serif`;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        const lines = stroke.text.split('\n');
                        lines.forEach((line, index) => {
                             ctx.fillText(line, stroke.x, stroke.y + index * (stroke.fontSize * 1.2)); // Simple line height
                        });
                    }
                    // 'fill' tool doesn't need drawing here, it affects the background clear
                });
                ctx.globalCompositeOperation = originalCompositeOperation; // Restore original state if needed
           };

            const resizeCanvas = () => { if (!canvas || !canvas.parentElement) return; const parent = canvas.parentElement; const ratio = window.devicePixelRatio || 1; canvas.width = parent.clientWidth * ratio; canvas.height = parent.clientHeight * ratio; canvas.style.width = parent.clientWidth + 'px'; canvas.style.height = parent.clientHeight + 'px'; ctx.scale(ratio, ratio); renderAll(); };

            // --- Whiteboard Drawing/Text Functions ---
            const getXY = (e) => { const rect = canvas.getBoundingClientRect(); const clientX = e.clientX ?? e.touches?.[0]?.clientX; const clientY = e.clientY ?? e.touches?.[0]?.clientY; if (clientX === undefined || clientY === undefined) { return null; } return { x: clientX - rect.left, y: clientY - rect.top }; };

            const startDrawing = (event) => {
                // Fix: Prevent default only for touch to avoid interfering with text selection etc.
                if (event.type === 'touchstart') event.preventDefault();

                // If in text mode, create text input instead of drawing
                if (currentTool === 'text') {
                    finalizeTextInput(); // Finalize any existing text input first
                    createTextInput(event);
                    return; // Don't proceed with drawing logic
                }

                finalizeTextInput(); // Finalize text if user starts drawing/erasing
                const pos = getXY(event);
                if (!pos) return;
                drawing = true;
                const currentLineWidth = parseInt(brushSizeSelect.value, 10);

                if (currentTool === 'eraser') {
                    currentStroke = { tool: 'eraser', color: '#000000', lineWidth: currentLineWidth, points: [pos] };
                    ctx.globalCompositeOperation = 'destination-out'; // Set for active drawing
                } else { // Pen tool
                    currentStroke = { tool: 'pen', color: colorPicker.value, lineWidth: currentLineWidth, points: [pos] };
                    ctx.globalCompositeOperation = 'source-over'; // Set for active drawing
                }
                ctx.strokeStyle = currentStroke.color; // Set style for the path
                ctx.lineWidth = currentLineWidth;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
            };

           const draw = (event) => {
               if (!drawing || !currentStroke || currentTool === 'text') return;
                // Fix: Prevent default only for touch
                if (event.type === 'touchmove') event.preventDefault();

               const pos = getXY(event);
               if (!pos) return;

               // Ensure correct composite op is set *during* drawing
               ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
               ctx.lineTo(pos.x, pos.y);
               ctx.stroke(); // Draw the segment
               currentStroke.points.push(pos);
            };

           const stopDrawing = () => {
               if (!drawing || currentTool === 'text') return;
               drawing = false;
               if (currentStroke && currentStroke.points.length > 1) { strokes.push(currentStroke); }
               currentStroke = null;
               ctx.globalCompositeOperation = 'source-over'; // Reset composite op after drawing stops
            };

            // --- Text Input Handling ---
            function createTextInput(e) {
                 if (textInputOverlay) { document.body.removeChild(textInputOverlay); }
                 const pos = getXY(e);
                 if (!pos) return;

                 textInputOverlay = document.createElement('textarea');
                 textInputOverlay.id = 'text-input-overlay';
                 // Position relative to the document, considering scroll
                 textInputOverlay.style.left = `${e.clientX + window.scrollX}px`;
                 textInputOverlay.style.top = `${e.clientY + window.scrollY}px`;
                 textInputOverlay.style.fontSize = `${fontSizeSelect.value}px`;
                 textInputOverlay.style.color = colorPicker.value;
                 textInputOverlay.wrap = 'soft';

                 textInputOverlay.addEventListener('keypress', (event) => {
                     if (event.key === 'Enter' && !event.shiftKey) {
                         event.preventDefault();
                         finalizeTextInput();
                     }
                 });

                 // Add blur event to finalize text when losing focus
                 textInputOverlay.addEventListener('blur', finalizeTextInput, { once: true }); // Use once to auto-remove

                 document.body.appendChild(textInputOverlay);
                 textInputOverlay.focus();

                 // Prevent the mousedown that triggered this from immediately causing a blur
                 e.stopPropagation();
             }

             function finalizeTextInput() {
                 if (!textInputOverlay) return;
                 const text = textInputOverlay.value.trim();
                 // Calculate position relative to canvas, compensating for scroll
                 const canvasRect = canvas.getBoundingClientRect();
                 const overlayRect = textInputOverlay.getBoundingClientRect();
                 const x = overlayRect.left - canvasRect.left;
                 const y = overlayRect.top - canvasRect.top;

                 const fontSize = parseInt(fontSizeSelect.value, 10);
                 const color = colorPicker.value;

                 if (text) {
                     strokes.push({ tool: 'text', text: text, x: x, y: y, fontSize: fontSize, color: color });
                     renderAll();
                 }
                  if (textInputOverlay.parentNode) { // Check if it still exists before removing
                     document.body.removeChild(textInputOverlay);
                  }
                 textInputOverlay = null;
                 // No need to remove blur listener explicitly if using { once: true }
             }

             // --- Set Cursor & Eraser Preview ---
             function updateCursor() { canvas.className = ''; /* Clear old cursors */ if (currentTool === 'pen') canvas.classList.add('pen-cursor'); else if (currentTool === 'text') canvas.classList.add('text-cursor'); else if (currentTool === 'eraser') canvas.classList.add('eraser-cursor'); }
             function showEraserPreview(e) { if (currentTool !== 'eraser' || !eraserPreview) return; const pos = getXY(e); if(!pos) return; const size = parseInt(brushSizeSelect.value, 10); const canvasRect = canvas.getBoundingClientRect(); eraserPreview.style.width = `${size}px`; eraserPreview.style.height = `${size}px`; eraserPreview.style.left = `${pos.x + canvasRect.left + window.scrollX - size / 2}px`; eraserPreview.style.top = `${pos.y + canvasRect.top + window.scrollY - size / 2}px`; eraserPreview.style.display = 'block'; }
             function hideEraserPreview() { if (eraserPreview) eraserPreview.style.display = 'none'; }

            // --- Whiteboard Event Listeners ---
           canvas.addEventListener('mousedown', startDrawing);
           canvas.addEventListener('mousemove', (e) => { draw(e); if(currentTool === 'eraser') showEraserPreview(e); });
           canvas.addEventListener('mouseup', stopDrawing);
           canvas.addEventListener('mouseleave', () => { stopDrawing(); hideEraserPreview(); });
           canvas.addEventListener('mouseenter', (e) => { if(currentTool === 'eraser') showEraserPreview(e); });
           canvas.addEventListener('touchstart', (e) => { startDrawing(e.touches[0]); hideEraserPreview(); document.body.style.overflow = 'hidden'; }, { passive: false });
           canvas.addEventListener('touchmove', (e) => { draw(e.touches[0]); }, { passive: false });
           canvas.addEventListener('touchend', () => { stopDrawing(); document.body.style.overflow = ''; });
           canvas.addEventListener('touchcancel', () => { stopDrawing(); document.body.style.overflow = ''; });

            // Tool Selection
            toolButtons.forEach(button => {
                 button.addEventListener('click', function() {
                     finalizeTextInput(); // Finalize text if switching tool
                     toolButtons.forEach(btn => btn.classList.remove('active'));
                     this.classList.add('active');
                     currentTool = this.dataset.tool;
                     updateCursor();
                     // No need to set composite op here, it's handled in draw/start/render
                 });
             });

           // Control listeners
           colorPicker.addEventListener('input', () => { if (currentTool === 'pen' && !drawing) ctx.strokeStyle = colorPicker.value; });
           brushSizeSelect.addEventListener('change', () => { if (!drawing && (currentTool === 'pen' || currentTool === 'eraser')) ctx.lineWidth = parseInt(brushSizeSelect.value, 10); });

           // Action Buttons
           document.querySelector('.clear-button')?.addEventListener('click', () => { strokes = []; renderAll(); showNotification('Whiteboard cleared.'); });
           document.querySelector('.save-button')?.addEventListener('click', () => { try { localStorage.setItem('whiteboardStrokes', JSON.stringify(strokes)); showNotification('Whiteboard saved locally!'); } catch (e) { console.error('Error saving whiteboard:', e); showNotification('Failed to save: Storage limit likely exceeded.', 5000); } });
           document.querySelector('.load-button')?.addEventListener('click', () => { const data = localStorage.getItem('whiteboardStrokes'); if (data) { try { strokes = JSON.parse(data); renderAll(); showNotification('Whiteboard loaded!'); } catch (e) { showNotification('Error parsing saved drawing.'); strokes = []; renderAll(); } } else { showNotification('No saved drawing found.'); } });
           document.querySelector('.undo-button')?.addEventListener('click', () => { if (strokes.length > 0) { strokes.pop(); renderAll(); showNotification('Undo successful.'); } else { showNotification('Nothing to undo.'); } });
           document.querySelector('.fill-button')?.addEventListener('click', () => { strokes.push({ tool: 'fill', color: colorPicker.value }); renderAll(); showNotification('Canvas background filled.'); });
           document.querySelector('.export-png-button')?.addEventListener('click', () => { const dataURL = canvas.toDataURL('image/png'); const link = document.createElement('a'); link.href = dataURL; link.download = 'morrisons-dashboard-notes.png'; document.body.appendChild(link); link.click(); document.body.removeChild(link); showNotification('Downloaded as PNG.'); });

           window.addEventListener('resize', debounce(resizeCanvas, 200));
           resizeCanvas();
           updateCursor();
           const initialData = localStorage.getItem('whiteboardStrokes');
            if (initialData) { try { strokes = JSON.parse(initialData); renderAll(); } catch (e) { console.error("Could not load initial whiteboard data."); localStorage.removeItem('whiteboardStrokes'); } }

       } else { console.log("Whiteboard canvas not found."); }

        /* --- Lazy Load Iframes & Add Spinners --- */
        function initLazyIframes() { const iframes = document.querySelectorAll('iframe[data-src]'); const observerCallback = (entries, obs) => { entries.forEach(entry => { if (entry.isIntersecting) { const iframe = entry.target; const loader = iframe.previousElementSibling; if (loader && loader.classList.contains('iframe-loading')) { loader.style.display = 'block'; } iframe.src = iframe.getAttribute('data-src'); iframe.removeAttribute('data-src'); obs.unobserve(iframe); } }); }; const observerOptions = { rootMargin: '100px 0px', threshold: 0.01 }; const observer = new IntersectionObserver(observerCallback, observerOptions); iframes.forEach(iframe => { const parentContainer = iframe.parentElement; if(parentContainer.classList.contains('iframe-loading-container')) { const loader = parentContainer.querySelector('.iframe-loading'); if(loader) loader.style.display = 'none'; iframe.addEventListener('load', () => { if (loader) loader.style.display = 'none'; }); iframe.addEventListener('error', () => { if (loader) loader.style.display = 'none'; console.error("Error loading iframe:", iframe.title || iframe.src); }); if ('IntersectionObserver' in window) { observer.observe(iframe); } else { if (loader) loader.style.display = 'block'; iframe.src = iframe.getAttribute('data-src'); iframe.removeAttribute('data-src'); } } }); }

      /* --- DOMContentLoaded --- */
      document.addEventListener('DOMContentLoaded', () => { initLazyIframes(); });

    })();
  </script>
</body>
</html>
