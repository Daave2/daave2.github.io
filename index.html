
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Cleveleys Morrisons Management Dashboard for tasks, notes, scheduling, and operational guides.">
  <title>Cleveleys Morrisons Management Dashboard - Home</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    /* --- Base styles and other sections CSS remain identical --- */
    :root {
      --primary-green: #006400; --secondary-yellow: #FFD700; --background-faint-green: #e6ffe6; --background-white: #FFFFFF; --text-color: #333333; --card-bg: var(--background-white); --card-shadow: rgba(0, 0, 0, 0.1); --footer-bg: var(--primary-green); --footer-text: var(--background-white);
      /* Dark Mode Variables */
      --dark-background: #121212; --dark-card-bg: #1e1e1e; --dark-text-color: #e0e0e0; --dark-footer-bg: #333333; --dark-footer-text: #e0e0e0;
       /* Specific theme background colors for JS */
       --light-bg-color: #ffffff; /* Whiteboard light background */
       --dark-bg-color: #2e2e2e;  /* Whiteboard dark background */
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Roboto', sans-serif; background-color: var(--background-faint-green); color: var(--text-color); line-height: 1.6; transition: background-color 0.3s, color 0.3s; }
    body.dark-mode { background-color: var(--dark-background); color: var(--dark-text-color); --card-bg: var(--dark-card-bg); }
    a { color: inherit; text-decoration: none; }
    body.mobile-nav-open { overflow: hidden; }
    header { background-color: var(--background-white); color: var(--primary-green); padding: 20px 10px; text-align: center; position: relative; box-shadow: 0 2px 4px var(--card-shadow); transition: background-color 0.3s, color 0.3s; }
    body.dark-mode header { background-color: var(--dark-card-bg); color: var(--dark-text-color); box-shadow: 0 2px 4px var(--dark-card-bg); }
    header img { position: absolute; left: 20px; top: 50%; transform: translateY(-50%); height: 50px; transition: none; }
    header h1 { font-size: 2em; margin: 0; padding-left: 80px; }
     nav.nav { position: sticky; top: 0; z-index: 1000; background-color: var(--secondary-yellow); box-shadow: 0 2px 15px rgba(0,0,0,0.1); transition: background-color 0.3s; }
    body.dark-mode nav.nav { background-color: #333; box-shadow: 0 2px 15px rgba(0,0,0,0.6); }
    .nav-container { display: flex; align-items: center; justify-content: space-between; max-width: 1200px; margin: 0 auto; padding: 0 20px; height: 60px; }
    .nav-links { display: flex; align-items: center; gap: 1rem; list-style: none; transition: transform 0.3s ease; }
    .nav-links li { position: relative; }
    .nav-links a { display: flex; align-items: center; gap: 0.5rem; padding: 0.75rem 1rem; font-weight: 500; color: var(--primary-green); border-radius: 8px; transition: background-color 0.3s, transform 0.3s, color 0.3s; }
    body.dark-mode .nav-links a { color: var(--dark-text-color); }
    .nav-links a:hover { background-color: var(--primary-green); color: var(--background-white); transform: translateY(-2px); }
    .nav-links .active { background-color: var(--primary-green); color: var(--background-white); }
    .nav-links a::after { content: ''; position: absolute; bottom: 0; left: 0; width: 0; height: 3px; background-color: var(--primary-green); border-radius: 2px; transition: width 0.3s ease; }
    .nav-links a:hover::after, .nav-links .active::after { width: 100%; }
    .hamburger { display: none; flex-direction: column; cursor: pointer; z-index: 1001; }
    .hamburger span { display: block; width: 25px; height: 3px; background: var(--primary-green); margin: 5px 0; transition: all 0.3s ease; }
    body.dark-mode .hamburger span { background: var(--dark-text-color); }
    .hamburger.active span:nth-child(1) { transform: rotate(45deg) translate(5px, 5px); }
    .hamburger.active span:nth-child(2) { opacity: 0; }
    .hamburger.active span:nth-child(3) { transform: rotate(-45deg) translate(7px, -6px); }
    .nav-actions { display: flex; align-items: center; gap: 1rem; }
    .dark-mode-toggle { background: none; border: none; cursor: pointer; font-size: 1.5em; color: var(--primary-green); transition: color 0.3s; }
    body.dark-mode .dark-mode-toggle { color: var(--dark-text-color); }
     @media (max-width: 992px) { .hamburger { display: flex; } .nav-links { position: fixed; top: 60px; left: 0; right: 0; bottom: 0; background: var(--secondary-yellow); flex-direction: column; padding: 2rem 1rem; transform: translateX(-100%); transition: transform 0.3s ease-in-out; overflow-y: auto; z-index: 999; } body.dark-mode .nav-links { background: #333; } .nav-links.active { transform: translateX(0); } .nav-links li { margin: 0; width: 100%; } .nav-links a { margin: 0.5rem 0; width: 100%; justify-content: flex-start; padding: 1rem; font-size: 1.1em; border: 1px solid transparent; } body.dark-mode .nav-links a { color: var(--dark-text-color); } .nav-links a:hover { background-color: var(--primary-green); color: var(--background-white); border-color: var(--primary-green); } .nav-links .active { border-bottom: none; } .nav-links a::after { display: none; } }
    #dashboard { margin-bottom: 30px; background-color: var(--card-bg); padding: 20px; border-radius: 10px; box-shadow: 0 4px 12px var(--card-shadow); transition: background-color 0.3s, box-shadow 0.3s; }
    #dashboard h2 { color: var(--primary-green); margin-bottom: 15px; font-size: 1.6em; border-bottom: 2px solid var(--secondary-yellow); display: inline-block; padding-bottom: 5px; transition: color 0.3s, border-bottom-color 0.3s; }
    body.dark-mode #dashboard h2 { color: var(--secondary-yellow); border-bottom-color: var(--primary-green); }
    #dashboard .dashboard-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 20px; }
    #dashboard .dashboard-item { background-color: var(--primary-green); color: var(--background-white); border-radius: 10px; text-align: center; padding: 20px 10px; text-decoration: none; transition: background-color 0.3s, transform 0.3s; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; min-height: 100px; }
    #dashboard .dashboard-item:hover { background-color: #004d00; transform: translateY(-2px); }
    #dashboard .dashboard-item i { font-size: 2em; margin-bottom: 10px; }
    #dashboard .dashboard-item span { font-weight: bold; font-size: 0.9em; }
    #frame-container { display: none; max-width: 1200px; margin: 20px auto; position: relative; }
    #frame-container.active { display: block; }
    #content-frame { width: 100%; height: 600px; border: none; box-shadow: 0 4px 12px var(--card-shadow); border-radius: 10px; background-color: var(--background-white); }
    #close-frame { position: absolute; top: -40px; right: 0; background-color: var(--primary-green); color: var(--background-white); border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; font-size: 0.9em; }
    #close-frame:hover { background-color: #004d00; }
    #fallback-message { display: none; text-align: center; margin-top: 10px; padding: 15px; background-color: var(--secondary-yellow); color: var(--primary-green); border-radius: 5px; }
    #fallback-message a { color: var(--primary-green); text-decoration: underline; font-weight: bold; }
    .container { padding: 20px; max-width: 1200px; margin: 20px auto; }
    main { margin-bottom: 30px; }
    section { margin-bottom: 30px; background-color: var(--card-bg); padding: 25px; border-radius: 10px; box-shadow: 0 4px 12px var(--card-shadow); transition: background-color 0.3s, box-shadow 0.3s; }
    body.dark-mode section { background-color: var(--dark-card-bg); box-shadow: 0 4px 12px rgba(255, 255, 255, 0.05); }
    section h2 { color: var(--primary-green); margin-bottom: 20px; font-size: 1.8em; border-bottom: 2px solid var(--secondary-yellow); display: inline-block; padding-bottom: 8px; transition: color 0.3s, border-bottom-color 0.3s; }
    body.dark-mode section h2 { color: var(--secondary-yellow); border-bottom-color: var(--primary-green); }
    section p { margin-bottom: 1em; }
    section ul { list-style: disc; margin-left: 25px; margin-bottom: 1em; }
    .iframe-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; border-radius: 8px; box-shadow: 0 2px 8px var(--card-shadow); transition: box-shadow 0.3s, background-color 0.3s; margin-top: 15px; background-color: var(--background-white); }
    body.dark-mode .iframe-container { background-color: var(--dark-card-bg); box-shadow: 0 2px 8px rgba(255,255,255,0.1); }
    .iframe-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }
    @media (max-width: 768px) { .iframe-container { padding-bottom: 75%; } }
    /* --------------------------------------------------
       Whiteboard (Notes) Styles - UPDATED
       -------------------------------------------------- */
    .whiteboard-container { position: relative; width: 100%; height: 600px; border: 1px solid var(--primary-green); border-radius: 8px; background-color: var(--light-bg-color); overflow: hidden; transition: background-color 0.3s, border-color 0.3s; }
    body.dark-mode .whiteboard-container { background-color: var(--dark-bg-color); border-color: var(--dark-text-color); }
    #whiteboard { display: block; width: 100%; height: 100%; cursor: crosshair; background-color: transparent; /* Canvas itself is transparent */ }
    /* Improved Eraser Cursor */
    #whiteboard.eraser-active { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%23000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle></svg>') 12 12, auto; }
    body.dark-mode #whiteboard.eraser-active { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%23FFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle></svg>') 12 12, auto; }
    /* Text Input Overlay */
    #text-input-overlay { position: absolute; background: rgba(255, 255, 255, 0.9); border: 1px dashed var(--primary-green); padding: 5px; z-index: 20; resize: none; /* Prevent manual resize */ overflow: hidden; /* Hide scrollbars initially */ line-height: 1.2; /* Match font line height */ display: none; /* Hidden by default */ }
    body.dark-mode #text-input-overlay { background: rgba(50, 50, 50, 0.9); border-color: var(--secondary-yellow); color: var(--dark-text-color); }

    .button-group { position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 8px; z-index: 10; }
    .button-group button { background-color: var(--primary-green); color: #fff; border: none; padding: 6px 10px; border-radius: 5px; cursor: pointer; font-size: 0.85em; transition: background-color 0.3s; display: flex; align-items: center; gap: 5px; }
    .button-group button:hover { background-color: #004d00; }
    body.dark-mode .button-group button { background-color: #444; color: var(--dark-footer-text); }
    body.dark-mode .button-group button:hover { background-color: #222; }
    .button-group button.active { outline: 2px solid var(--secondary-yellow); box-shadow: 0 0 5px var(--secondary-yellow); }
    .whiteboard-tools { position: absolute; top: 10px; left: 10px; display: flex; gap: 8px; background: rgba(255, 255, 255, 0.9); padding: 8px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); z-index: 15; }
    body.dark-mode .whiteboard-tools { background: rgba(30, 30, 30, 0.9); }
    .color-picker, .brush-size, .font-size { height: 30px; border: 1px solid #ccc; border-radius: 4px; background: var(--card-bg); cursor: pointer; padding: 0 5px; }
    body.dark-mode .color-picker, body.dark-mode .brush-size, body.dark-mode .font-size { background: var(--dark-card-bg); color: var(--dark-text-color); border-color: #555; }
    /* --- End of Whiteboard CSS --- */
    footer { background-color: var(--footer-bg); color: var(--footer-text); text-align: center; padding: 15px 5px; width: 100%; transition: background-color 0.3s, color 0.3s; margin-top: 40px; }
    body.dark-mode footer { background-color: var(--dark-footer-bg); color: var(--dark-footer-text); }
    footer p { margin: 0; font-size: 0.9em; }
    html { scroll-behavior: smooth; }
    a:focus, button:focus, select:focus, input:focus, .hamburger:focus, [tabindex="0"]:focus { outline: 2px solid var(--primary-green); outline-offset: 2px; border-radius: 2px; }
    body.dark-mode a:focus, body.dark-mode button:focus, body.dark-mode select:focus, body.dark-mode input:focus, body.dark-mode .hamburger:focus, body.dark-mode [tabindex="0"]:focus { outline-color: var(--secondary-yellow); }
    .iframe-loading-container { position: relative; }
    .iframe-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid var(--primary-green); border-radius: 50%; animation: spin 1s linear infinite; z-index: 5; }
    body.dark-mode .iframe-loading { border-color: #555; border-top-color: var(--secondary-yellow); }
    @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }
    .notification { display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: var(--primary-green); color: white; padding: 10px 20px; border-radius: 5px; z-index: 2000; font-size: 0.9em; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
    body.dark-mode .notification { background-color: var(--secondary-yellow); color: var(--dark-background); }

  </style>
</head>
<body>
  <header> <!-- Header content --> </header>
  <nav class="nav" role="navigation" aria-label="Primary Navigation"> <!-- Navigation content --> </nav>

  <div class="container">
    <main>
       <!-- Intro Section - Shortened -->
       <section id="welcome">
        <h2>Welcome to the Dashboard</h2>
        <p>This dashboard provides quick access to essential tools, reports, and operational guides for Cleveleys Morrisons management. Please use the navigation bar or the quick links below to explore different sections.</p>
       </section>

      <!-- Dashboard Quick Links Section -->
      <section id="dashboard">
          <h2>Quick Links Dashboard</h2>
          <div class="dashboard-grid"> <!-- Dashboard items --> </div>
      </section>

      <!-- Content Frame Container -->
      <div id="frame-container"> <!-- Iframe loading structure --> </div>

      <!-- Who Is In Today Section -->
      <section id="who-is-in"> <!-- Who is in iframe --> </section>

      <!-- Management Rota Section -->
      <section id="management-rota"> <!-- Rota iframe --> </section>

       <!-- Wheel Section -->
      <section id="wheel"> <!-- Wheel iframe --> </section>

      <!-- Notes Section (Interactive Whiteboard) -->
      <section id="notes">
        <h2>Notes Whiteboard</h2>
        <p>Use the whiteboard for notes or brainstorming. Drawings & text can be saved/loaded locally. Use tools for color/size and buttons for actions.</p>
        <div class="whiteboard-container">
          <div class="whiteboard-tools">
            <input type="color" class="color-picker" value="#000000" aria-label="Select drawing/text color" title="Color">
            <select class="brush-size" aria-label="Select brush size" title="Brush Size">
              <option value="2">2px</option>
              <option value="4" selected>4px</option>
              <option value="8">8px</option>
              <option value="12">12px</option>
            </select>
             <select class="font-size" aria-label="Select font size" title="Font Size">
                <option value="14">14px</option>
                <option value="18" selected>18px</option>
                <option value="24">24px</option>
                <option value="32">32px</option>
            </select>
          </div>
          <canvas id="whiteboard" aria-label="Interactive whiteboard for notes"></canvas>
          <!-- Text input overlay - will be positioned by JS -->
          <textarea id="text-input-overlay" aria-label="Text input area"></textarea>
          <div class="button-group">
            <button class="pen-button active" title="Pen Tool"><i class="fas fa-pencil-alt"></i> Pen</button> <!-- Default active -->
            <button class="text-button" title="Text Tool"><i class="fas fa-font"></i> Text</button>
            <button class="eraser-button" title="Toggle eraser tool"><i class="fas fa-eraser"></i> Eraser</button>
            <button class="fill-button" title="Fill canvas background"><i class="fas fa-fill-drip"></i> Fill BG</button>
            <button class="undo-button" title="Undo last action"><i class="fas fa-undo"></i> Undo</button>
            <button class="clear-button" title="Clear whiteboard"><i class="fas fa-trash"></i> Clear</button>
            <button class="save-button" title="Save to local storage"><i class="fas fa-save"></i> Save</button>
            <button class="load-button" title="Load from local storage"><i class="fas fa-upload"></i> Load</button>
            <button class="export-png-button" title="Download as PNG"><i class="fas fa-download"></i> Download</button>
          </div>
        </div>
      </section>
    </main>
  </div>

  <footer> <!-- Footer content --> </footer>
  <div class="notification" id="notification" role="alert" aria-live="assertive"></div>

  <!-- JavaScript -->
  <script>
    (function() {
      'use strict';
      /* --- Helper: Debounce --- */
      function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func.apply(this, args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }

      /* --- Dark Mode Toggle --- */
      const darkModeToggleButtons = document.querySelectorAll('.dark-mode-toggle');
      function setDarkMode(isDark) { document.body.classList.toggle('dark-mode', isDark); darkModeToggleButtons.forEach(btn => btn.setAttribute('aria-pressed', isDark)); localStorage.setItem('theme', isDark ? 'dark' : 'light'); if (typeof resizeCanvas === 'function') { setTimeout(resizeCanvas, 50); } }
      darkModeToggleButtons.forEach(btn => { btn.addEventListener('click', () => setDarkMode(!document.body.classList.contains('dark-mode'))); });
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme) { setDarkMode(savedTheme === 'dark'); } else { const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; setDarkMode(prefersDark); }
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => { if (!localStorage.getItem('theme')) { setDarkMode(event.matches); } });

      /* --- Mobile Navigation Toggle --- */
      const hamburger = document.querySelector('.hamburger');
      const navLinks = document.querySelector('.nav-links');
      if (hamburger && navLinks) { const toggleNav = () => { const isActive = navLinks.classList.toggle('active'); hamburger.classList.toggle('active'); hamburger.setAttribute('aria-expanded', isActive); document.body.classList.toggle('mobile-nav-open', isActive); }; hamburger.addEventListener('click', (e) => { e.stopPropagation(); toggleNav(); }); hamburger.addEventListener('keypress', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); hamburger.click(); } }); document.addEventListener('click', (e) => { if (navLinks.classList.contains('active') && !navLinks.contains(e.target) && !hamburger.contains(e.target)) { toggleNav(); } }); navLinks.querySelectorAll('a').forEach(link => { link.addEventListener('click', () => { if (navLinks.classList.contains('active')) { toggleNav(); } }); }); }

      /* --- Notification System --- */
      function showNotification(message, duration = 3000) { const notification = document.getElementById('notification'); if (!notification) return; notification.textContent = message; notification.style.display = 'block'; notification.style.opacity = 1; setTimeout(() => { notification.style.opacity = 0; setTimeout(() => { notification.style.display = 'none'; }, 300); }, duration); }

      /* --- Dashboard Item Click Handler & Iframe --- */
      // ... (Iframe loading code remains the same as previous version) ...
        const dashboardItems = document.querySelectorAll('#dashboard .dashboard-item');
       const frameContainer = document.getElementById('frame-container');
       const contentFrame = document.getElementById('content-frame');
       const closeFrame = document.getElementById('close-frame');
       const fallbackMessage = document.getElementById('fallback-message');
       const fallbackLink = document.getElementById('fallback-link');
       const frameSpinner = frameContainer ? frameContainer.querySelector('.iframe-loading') : null;
       let frameLoadTimeout;
       function showFrameSpinner(show) { if (frameSpinner) frameSpinner.style.display = show ? 'block' : 'none'; }
       function loadContentInFrame(url) { if (!frameContainer || !contentFrame || !fallbackLink || !fallbackMessage || !closeFrame ) return; contentFrame.src = "about:blank"; fallbackMessage.style.display = "none"; fallbackLink.href = url; frameContainer.classList.add('active'); showFrameSpinner(true); contentFrame.src = url; clearTimeout(frameLoadTimeout); frameLoadTimeout = setTimeout(() => { showFrameSpinner(false); fallbackMessage.style.display = "block"; showNotification("Content took too long to load.", 4000); }, 15000); frameContainer.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
       if (contentFrame) { contentFrame.onload = function() { clearTimeout(frameLoadTimeout); showFrameSpinner(false); let accessible = false; try { const doc = contentFrame.contentDocument || contentFrame.contentWindow?.document; if (doc && doc.body && doc.body.childNodes.length > 0) { accessible = true; } else if (doc) { accessible = true; } } catch (e) { accessible = true; console.warn("Cross-origin frame loaded.", e); } fallbackMessage.style.display = accessible ? "none" : "block"; }; contentFrame.onerror = function() { clearTimeout(frameLoadTimeout); showFrameSpinner(false); fallbackMessage.style.display = "block"; showNotification("Error loading content in frame.", 4000); }; }
       dashboardItems.forEach(item => { item.addEventListener('click', function(e) { const url = this.getAttribute('href'); const openType = this.dataset.open; if (openType === "external") { e.preventDefault(); window.open(url, '_blank', 'noopener,noreferrer'); } else if (openType === "frame") { e.preventDefault(); loadContentInFrame(url); } }); });
       if (closeFrame) { closeFrame.addEventListener('click', function() { if (!frameContainer || !contentFrame) return; frameContainer.classList.remove('active'); contentFrame.src = "about:blank"; fallbackMessage.style.display = "none"; showFrameSpinner(false); clearTimeout(frameLoadTimeout); }); }


      /* --- Whiteboard Setup --- */
      const canvas = document.getElementById('whiteboard');
      let ctx, colorPicker, brushSizeSelect, fontSizeSelect, textInputOverlay,
          strokes = [], currentStroke = null, currentTool = 'pen', drawing = false, textInputActive = false;

      if (canvas) {
           ctx = canvas.getContext('2d');
           colorPicker = document.querySelector('.color-picker');
           brushSizeSelect = document.querySelector('.brush-size');
           fontSizeSelect = document.querySelector('.font-size'); // Get font size selector
           textInputOverlay = document.getElementById('text-input-overlay');

           const getEffectiveBackgroundColor = () => {
                const lastFill = strokes.slice().reverse().find(stroke => stroke.tool === 'fill');
                if (lastFill) return lastFill.color;
                const styles = getComputedStyle(document.documentElement);
                return document.body.classList.contains('dark-mode') ? styles.getPropertyValue('--dark-bg-color').trim() : styles.getPropertyValue('--light-bg-color').trim();
            };

           const renderAll = () => {
               if (!ctx) return;
               const ratio = window.devicePixelRatio || 1;
               const width = canvas.width / ratio;
               const height = canvas.height / ratio;
               const originalCompositeOperation = ctx.globalCompositeOperation;
               const originalFillStyle = ctx.fillStyle; // Save original fill style

               // --- Clear canvas with effective background ---
                ctx.globalCompositeOperation = 'source-over'; // Ensure normal drawing mode for clear
                ctx.fillStyle = getEffectiveBackgroundColor();
                ctx.fillRect(0, 0, width, height);


               // --- Draw strokes ---
               strokes.forEach(stroke => {
                   if (!stroke) return;
                   ctx.lineJoin = 'round';
                   ctx.lineCap = 'round';

                   if (stroke.tool === 'pen' || stroke.tool === 'eraser') {
                       if (!stroke.points || stroke.points.length < 1) return;
                       ctx.lineWidth = stroke.lineWidth;
                       ctx.strokeStyle = stroke.color; // Use stored color
                       ctx.globalCompositeOperation = stroke.tool === 'eraser' ? 'destination-out' : 'source-over';
                       ctx.beginPath();
                       ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                       for (let i = 1; i < stroke.points.length; i++) {
                            if (stroke.points[i]) ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                       }
                       ctx.stroke();
                   } else if (stroke.tool === 'text') {
                       ctx.globalCompositeOperation = 'source-over'; // Ensure normal drawing for text
                       ctx.fillStyle = stroke.color;
                       ctx.font = `${stroke.fontSize}px Roboto, sans-serif`;
                       ctx.textAlign = 'left';
                       ctx.textBaseline = 'top';
                       // Draw multi-line text
                       const lines = stroke.text.split('\n');
                       lines.forEach((line, index) => {
                           ctx.fillText(line, stroke.x, stroke.y + index * (stroke.fontSize * 1.2)); // Adjust line height slightly
                       });
                   }
                   // 'fill' tool doesn't draw here, it affects the background clear
               });

               // --- Restore context state ---
               ctx.globalCompositeOperation = originalCompositeOperation;
                ctx.fillStyle = originalFillStyle; // Restore fill style
               // Restore current tool settings for cursor etc.
               ctx.lineWidth = parseInt(brushSizeSelect.value, 10);
               ctx.strokeStyle = colorPicker.value;

           };

           const resizeCanvas = () => { if (!canvas || !canvas.parentElement) return; const parent = canvas.parentElement; const ratio = window.devicePixelRatio || 1; canvas.width = parent.clientWidth * ratio; canvas.height = parent.clientHeight * ratio; canvas.style.width = parent.clientWidth + 'px'; canvas.style.height = parent.clientHeight + 'px'; ctx.scale(ratio, ratio); renderAll(); };

           const getXY = (e) => { const rect = canvas.getBoundingClientRect(); const clientX = e.clientX ?? e.touches?.[0]?.clientX; const clientY = e.clientY ?? e.touches?.[0]?.clientY; if (clientX === undefined || clientY === undefined) { return null; } return { x: clientX - rect.left, y: clientY - rect.top }; };

           const handleTextInput = (startX, startY) => {
                if (textInputActive) return; // Prevent multiple text boxes
                textInputActive = true;
                textInputOverlay.style.left = `${startX}px`;
                textInputOverlay.style.top = `${startY}px`;
                textInputOverlay.style.display = 'block';
                textInputOverlay.style.fontSize = `${fontSizeSelect.value}px`;
                textInputOverlay.style.color = colorPicker.value;
                textInputOverlay.value = '';
                textInputOverlay.focus();

                const finalizeText = () => {
                    if (!textInputActive) return;
                    const text = textInputOverlay.value.trim();
                    if (text) {
                        strokes.push({
                            tool: 'text',
                            text: text,
                            x: startX,
                            y: startY,
                            color: colorPicker.value,
                            fontSize: parseInt(fontSizeSelect.value, 10)
                        });
                        renderAll();
                    }
                    textInputOverlay.style.display = 'none';
                    textInputActive = false;
                     // Remove listeners specific to this text input session
                     textInputOverlay.onblur = null;
                     textInputOverlay.onkeydown = null;
                };

                // Finalize on blur
                textInputOverlay.onblur = finalizeText;

                // Finalize on Enter (but allow Shift+Enter for new lines)
                textInputOverlay.onkeydown = (e) => {
                     if (e.key === 'Enter' && !e.shiftKey) {
                         e.preventDefault(); // Prevent default Enter behavior (new line)
                         finalizeText();
                    } else if (e.key === 'Escape') {
                        // Cancel on Escape
                         textInputOverlay.value = ''; // Clear just in case
                         finalizeText();
                    }
                };
            };


            const startDrawing = (e) => {
                if (textInputActive) { // If text input is active, finalize it first
                    textInputOverlay.blur(); // Trigger finalization logic
                    return;
                 }
                if (currentTool === 'text') {
                    const pos = getXY(e);
                    if(pos) handleTextInput(pos.x, pos.y);
                    return; // Don't start drawing path for text tool
                }

                const pos = getXY(e);
                if (!pos) return;
                drawing = true;
                const currentLineWidth = parseInt(brushSizeSelect.value, 10);
                const isEraser = currentTool === 'eraser';

                currentStroke = {
                    tool: isEraser ? 'eraser' : 'pen',
                    color: isEraser ? '#000000' : colorPicker.value, // Store color even for eraser for potential future use/type checking
                    lineWidth: currentLineWidth,
                    points: [pos]
                };

                ctx.lineWidth = currentLineWidth;
                ctx.strokeStyle = isEraser ? '#000000' : colorPicker.value; // Eraser uses black conceptually for destination-out
                ctx.globalCompositeOperation = isEraser ? 'destination-out' : 'source-over';
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
            };

           const draw = (e) => {
               if (!drawing || !currentStroke || currentTool === 'text') return;
               const pos = getXY(e);
               if (!pos) return;
               const isEraser = currentTool === 'eraser';

               ctx.globalCompositeOperation = isEraser ? 'destination-out' : 'source-over';
               ctx.lineTo(pos.x, pos.y);
               ctx.stroke();
               currentStroke.points.push(pos);
            };

           const stopDrawing = () => {
               if (!drawing || currentTool === 'text') return;
               drawing = false;
               if (currentStroke && currentStroke.points.length > 1) { strokes.push(currentStroke); }
               currentStroke = null;
               ctx.globalCompositeOperation = 'source-over'; // Reset
            };

            // --- Whiteboard Event Listeners ---
           canvas.addEventListener('mousedown', (e) => startDrawing(e));
           canvas.addEventListener('mousemove', (e) => draw(e));
           canvas.addEventListener('mouseup', stopDrawing);
           canvas.addEventListener('mouseleave', stopDrawing);
           canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrawing(e.touches[0]); document.body.style.overflow = 'hidden'; }, { passive: false });
           canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e.touches[0]); }, { passive: false });
           canvas.addEventListener('touchend', () => { stopDrawing(); document.body.style.overflow = ''; });
           canvas.addEventListener('touchcancel', () => { stopDrawing(); document.body.style.overflow = ''; });

            // --- Tool/Button Listeners ---
            const toolButtons = {
                pen: document.querySelector('.pen-button'),
                text: document.querySelector('.text-button'),
                eraser: document.querySelector('.eraser-button'),
                 fill: document.querySelector('.fill-button') // Added fill
            };

             const setActiveTool = (toolName) => {
                if (textInputActive) textInputOverlay.blur(); // Finalize text if switching tool
                currentTool = toolName;
                Object.values(toolButtons).forEach(btn => btn?.classList.remove('active'));
                if (toolButtons[toolName]) {
                    toolButtons[toolName].classList.add('active');
                 }
                 canvas.classList.toggle('eraser-active', toolName === 'eraser');
                 ctx.globalCompositeOperation = toolName === 'eraser' ? 'destination-out' : 'source-over';
             };

            toolButtons.pen?.addEventListener('click', () => setActiveTool('pen'));
            toolButtons.text?.addEventListener('click', () => setActiveTool('text'));
            toolButtons.eraser?.addEventListener('click', () => setActiveTool('eraser'));

           colorPicker.addEventListener('input', () => { if (currentTool === 'pen') ctx.strokeStyle = colorPicker.value; });
           brushSizeSelect.addEventListener('change', () => { if (currentTool === 'pen' || currentTool === 'eraser') ctx.lineWidth = parseInt(brushSizeSelect.value, 10); });
           // Font size select listener (no immediate canvas change needed)
           fontSizeSelect.addEventListener('change', () => {
                if(textInputActive) textInputOverlay.style.fontSize = `${fontSizeSelect.value}px`;
           });

           document.querySelector('.clear-button')?.addEventListener('click', () => { strokes = []; renderAll(); showNotification('Whiteboard cleared.'); });
           document.querySelector('.save-button')?.addEventListener('click', () => { try { localStorage.setItem('whiteboardStrokes', JSON.stringify(strokes)); showNotification('Whiteboard saved locally!'); } catch (e) { console.error('Error saving whiteboard:', e); showNotification('Failed to save: Storage limit likely exceeded.', 5000); } });
           document.querySelector('.load-button')?.addEventListener('click', () => { const data = localStorage.getItem('whiteboardStrokes'); if (data) { try { strokes = JSON.parse(data); renderAll(); showNotification('Whiteboard loaded!'); } catch (e) { showNotification('Error parsing saved drawing.'); strokes = []; renderAll(); } } else { showNotification('No saved drawing found.'); } });
           document.querySelector('.undo-button')?.addEventListener('click', () => { if (strokes.length > 0) { strokes.pop(); renderAll(); showNotification('Undo successful.'); } else { showNotification('Nothing to undo.'); } });
           document.querySelector('.fill-button')?.addEventListener('click', () => { strokes.push({ tool: 'fill', color: colorPicker.value }); renderAll(); showNotification('Canvas background filled.'); setActiveTool('pen'); }); // Switch back to pen after fill
           document.querySelector('.export-png-button')?.addEventListener('click', () => { const dataURL = canvas.toDataURL('image/png'); const link = document.createElement('a'); link.href = dataURL; link.download = 'morrisons-dashboard-notes.png'; document.body.appendChild(link); link.click(); document.body.removeChild(link); showNotification('Downloaded as PNG.'); });

           window.addEventListener('resize', debounce(resizeCanvas, 200));
           resizeCanvas();
           const initialData = localStorage.getItem('whiteboardStrokes');
            if (initialData) { try { strokes = JSON.parse(initialData); renderAll(); } catch (e) { console.error("Could not load initial whiteboard data."); localStorage.removeItem('whiteboardStrokes'); } }

           // Set initial tool state
           setActiveTool('pen');

       } else { console.log("Whiteboard canvas not found."); }

        /* --- Lazy Load Iframes & Add Spinners --- */
        function initLazyIframes() { const iframes = document.querySelectorAll('iframe[data-src]'); const observerCallback = (entries, obs) => { entries.forEach(entry => { if (entry.isIntersecting) { const iframe = entry.target; const loader = iframe.previousElementSibling; if (loader && loader.classList.contains('iframe-loading')) { loader.style.display = 'block'; } iframe.src = iframe.getAttribute('data-src'); iframe.removeAttribute('data-src'); obs.unobserve(iframe); } }); }; const observerOptions = { rootMargin: '100px 0px', threshold: 0.01 }; const observer = new IntersectionObserver(observerCallback, observerOptions); iframes.forEach(iframe => { const parentContainer = iframe.parentElement; if(parentContainer.classList.contains('iframe-loading-container')) { const loader = parentContainer.querySelector('.iframe-loading'); if(loader) loader.style.display = 'none'; iframe.addEventListener('load', () => { if (loader) loader.style.display = 'none'; }); iframe.addEventListener('error', () => { if (loader) loader.style.display = 'none'; console.error("Error loading iframe:", iframe.title || iframe.src); }); if ('IntersectionObserver' in window) { observer.observe(iframe); } else { if (loader) loader.style.display = 'block'; iframe.src = iframe.getAttribute('data-src'); iframe.removeAttribute('data-src'); } } }); }

      /* --- DOMContentLoaded --- */
      document.addEventListener('DOMContentLoaded', () => { initLazyIframes(); });

    })();
  </script>
</body>
</html>
